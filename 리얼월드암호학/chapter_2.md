# 해시함수

첫 번쨰 암호학의 구성 요소로 **해시함수**를 소개한다

해시 함수는 데이터를 입력으로 받아 고유한 바이트 문자열을 생성한다.

동일한 입력이 주어지면 해시 함수는 항상 동일한 바이트 문자열을 생성

## 해시 함수란?

> 해시 함수의 출력을 다이제스트 또는 해시라고 한다

SHA-256 해시 함수를 사용하여 입력을 고유 식벽자로 변환

이러한 절차로 인해 무결성과 진본성을 얻을수 있다.

이 모든 것은 **제 2 역상 저항성**이라는 해시 함수의 보안 속성 덕분이다.

제 2 역상 저항성이란 해시 함수의 출력에 해당하는 긴 문자열을 생성할 수 있는 해시 함수의 입력이 유일하다는 성질을 의미

이 다이제스트는 다운로드한 입력 파일과 일대일 대응되며, 공격자가 사용자가가 다운로드 하는 파일 대신 다른 파일을 심어도 사용자는 해시 함수의 출력 덕분에 속지 않을 수 있다.

해시 함수의 다이제스트는 웹페이지 소유자가 게시하는 것이며, 웹 페이지를 수정할 수 있는 모든 사람이 바꿀 수 있다.
즉 다이제스트를 게시한 웹페이지, 소유자, 페이즈를 불러오는 메커니즘을 모두 신뢰핤 수 있어야 올바른 파일을 내려받았다는 사실을 확신할 수 있다.
이런 점을 감안하면 **해시 함수만드론느 무결성을 얻을 수 없다**
다운로드한 파일의 무결성 및 진본성은 다이제스트를 제공하는 신뢰할 만한 메커니즘과 다이제스트를 통해 확보할 수 있다

해시 함수는 임의의 길이의 입력을 받아 고정된 길이 출력을 생성한다. 동일한 입력을 해시하면 동일한 다이제스트가 생성된다

출력은 항상 동일한 길이를 가지며 결정론적이다.

## 해시 함수의 보안 속성

해시 함수는 세 가지 보안 속성을 제공하기 위해 정의된 구조이다.

첫 번쨰는 **역상 저항성**이다
이 속성은 주어진 출력을 입력으로 바꾸는 역함수를 누구도 만들 수 없는 성질이다.
해시 함수는 믹서기와 같아서 만들어진 스무디에서 재료를 회수하는 것은 불가능하다.
즉 이 함수는 일방향성이다

입력값의 범위가 굉장히 좁다면 어떻게 될까?
oui, non과 같은 문자열이 입력이라고 가정해보자, 그러면 누군가 가능한 모든 알파벳 3글자 단어를 해시하는 방법으로 입력이 무엇인지 알아낼 수 있다.
입력 공간이 작다면? 예를 들어 나는 월요일 오전 3시에 집에 갈 것이다 라는 긴 문장을 해시하면 문장에서 바뀌는 부분이 요일, 시간처럼 일부에 불과해 공격자가 가능한 모든 요일과 시간을 시도하다 보면 올바른 해시값을 찾아낼 수 있을것이다.
이 첫 번째 보안 속성, 역상 저항성은 너무 작거나 예측 가능한 것을 숨길 수 없다 라는 명백한 단점을 가진다.

두 번째 속성은 **제 2 역상 저항성**이다.
이 속성의 의미는 입력과 입력에 해당하는 다이제스트가 주어졌을때 해당 다이제스트를 생성하는 다른 입력을 찾을 수 없다라는 뜻이다.

마지막 세 번쨰 속성은 **충돌 저항성**이다.
아무도 동일한 출력을 만드는 두 개의 다른 입력을 생성할 수 없도록 보장한다
동일한 출력값을 발생시키는 두 개의 입력을 찾을 수 없다.

## 해시 함수의 보안 제약

- 역상 저항성
- 제 2 역상 저항성
- 충돌 저항성

보안 속성은 그 자체로는 의미가 없다. 보안 속성은 해시 함수를 어떻게 사용하냐에 따라 의미를 가진다. 그러므로 실제 해시 함수를 살펴보기 전에 이러한 보안 속성의 몇 가지 제약을 이해하는 것이 중요하다

첫쨰,이러한 보안 속성은 해시 함수를 사용하고 있다고 가정한다.
yes 나 no라는 단어를 해시하고 다이제스트를 게시한다고 생각해보자, 공격자가 두 단어중 하나를 해시한다는 사실을 알면, 두 단어를 모두 해시해보고 결과를 필자가 해시한 결과와 비교할 수 있다.
이렇기에 해시 함수의 역상 저항성은 꺨 수 있다고 생각할수 있지만 입력의 무작위성이 충분하지 않았다.
또한 해시 함수는 임의의 길이의 입력을 받아들이고 항상 같은 길이의 출력을 생성하므로 동일한 길이의 해시 출력을 발생시키는 입력은 무한히 존재할 수 있다.
이렇게 되면 제 역상 저항성이 꺠지는 것이 아닌가 생각 할 수 있다.
제 2 역상 저항성은 같은 출력을 만드는 다른 입력을 찾는 것이 매우 어렵기 떄문에 구현이 이론적으로 아예 불가능하지는 않지만 실질적으로 불가능하다

둘째, 다이제스트의 크기가 중요하다
해시 함수만의 특성이 아니다. 모든 암호화 알고리즘에서 파라미터의 크기는 중요한 요소이다.
길이 2비트의 출력을 무작위로 균일하게 생성하는 해시 함수가 있다고 가정해보자, 이경우 몇 번 해시를 하다보면 충돌이 생겨난다.
그렇기에 해시 함수가 실제로 생성해야 하는 **최소 출력 크긱**는 256비트이다. 이는 상당한 길이의 출력이기에 컴퓨터 역사에서 한 획을 긋는 획기적인 사건이 발생하지 않는 한 총돌에 도달 할 수는 없다

이 256비트는 어떻게 나온 수 일까? 실제 암호학에서 알고리즘은 최소 128비트의 보안을 목표로 한다.
이는 알고리즘을 꺠고자 하는 공격자가 2^128회의 작업을 수행해야 함을 의미한다.
해시 함수가 앞에서 언급한 세가지 보안 속성을 모두 제공하려면 세 가지 공격 모두 최소 128비트의 보안을 제공해야한다.
가장 쉬운 공격은 일반적으로 생일 경계로 인한 충돌을 찾는 것이다.

> 생일 경계
> 생일 경계는 생일 문제가 일부 직관적이지 않은 결과를 드러낸다는 확률 이론에서 유래
> 한 방에 어려 사람이 있을때 최소 50% 확률로 두 사람이 같은 생일을 가지려면 한 방에 몇명이 필요한가?
> 정답은 무작위로 23명을 뽑으면 이 확률에 도달하기에 충분하다
> 이를 **생일 역설**이라 한다. 2^n 가지 가능성이 있는 공간에서 문자열을 무작위로 생성할때 약 2^(n/2)개의 문자열을 생성하면 충돌을 발견할 확률을 50%로 예상할 수 있다.

해시 함수가 256비트의 임의 출력을 생성하는 경우 모든 출력의 공간 크기는 2^256이다. 이는 2^128개의 다이제스트를 생성한 후 총돌이 발견된 가능성이 높다는 의미다
128비트의 보안이 목표로 하는 숫자라면 해시 함수도 최소한 256비트 출력을 제공해야 한다.

특정 제약 조건으로 인해 개발자가 다이제스트를 잘라내어 크기를 줄여야 하는 상황도 있을 수 있다.
이론적으로는 간으하지만 이는 보안을 크게 저하시킬 수 있다.

128비트 보안을 달성하려면 최소한 다음과 같은 다이제스트 길이가 필요하다

- 충돌 저항성을 위해서는 256비트
- 역상 저항성 및 제 2역상 저항성을 위해서는 128비트

즉 어떤 속성이 더 중요한지에 따라 해시 함수의 출력을 잘라 더 짧은 다이제스트를 사용할 수도 있다.

## 해시 함수의 실사용

해시 함수는 보통 단독으로 쓰이지 않는다. 해시 함수는 보통 다른 요소와 결합하여 암호학 프리미티브, 또는 암호학 프로토콜을 구성한다

### 커밋

메세지를 해시하고 출력 내용을 상대방에게 넘긴다. 시간이 지난후 메시지를 공개한다. 상대방은 받은 출력 내용을 해시해서 실제로 동일한 출력임을 확인한다.

이것을 커밋 체계라고 부른다. 암호학에서 커밋은 두 가지 속성을 가진다

- 숨기기: 커밋은 기본값을 숨겨야 한다
- 바인딩: 커밋은 하나의 값을 숨겨야 한다. 즉 값 x로 커밋하면 나중에 다른 값 y가 나올 수 없다.

### 서브리소스 무결성

CDN이 악의적으로 악성 자바스크립트 파일을 제공한다면 이는 실제로 큰 문제가 될 수 있다.
이에 대응하기 위해 웹페이지는 가져오기 태그에 다이제스트를 포함시킬 수 있는 **서브리소스 무결성**이라는 기능을 사용할 수 있다.

자바스크립트 파일을 받으면 브라우저는 이를 해시하고, 페이지에 하드코딩된 다이제스트에 해당하는지 확인한다.
일치 여부가 확인되면 무결성이 검증된 자바스크립트 파일을 실행한다

### 비트토렌트

전 세계 사용자는 비트토렌트 프로토콜을 사용하여 서로 간에 직접 파일을 공유한다.

피어는 파일을 배포하기 위해 파일을 청크로 자르고 각 청크를 개별적으로 해시한다.
각 청크의 해시는 다운로드할 파일을 나타내는 신뢰의 원천으로서 공유된다.

비트토렌트는 피어가 다른 피어로부터 파일의 서로 다른 청크를 얻을 수 있도록 하는 몇 가지 메커니즘이 있다. 결국 전체 파일의 무결성은 다운로드된 각 청크를 해시하고 그 출력을 알려진 다이제스트와 일치시켜서 확인한다.

### 토르

토르 브라우저의 또 다른 기능은 물리적 위치를 추적하기 어려운 숨겨진 웹페이지를 만드는 것이다.
이러한 페이지에 대한 연결은 웹페이지의 공개 키를 사용하는 프로토콜을 통햇 보호된다.

해시 함수는 다음과 같은 상황에서 **내용의 무결성** 또는 인증을 제공했다

- 누군가가 내용을 조적할 수 있다
- 해시를 안전하게 전달할 수 있다

보안을 위햇 우리는 무언가를, 또는 누군가를 **인증**한다고 표현, 이때 중요한 것은 해시를 안전하게 전달할 수 없다면 누구나 해시를 다른 해시로 대채할 수 있다는 점이다.
따라서 해시 자체만으로는 무결성을 얻을 수 없다.ㄴ

## 표준화된 해시 함수

첫째, CRC32와 같은 함수는 암호화 해시 함수가 아니라 오류 감지 코드 함수다.
몇 가지 간단한 오류를 감지하는 데 도움이 되지만 언급한 보안 속성은 제공하지 않으며, 해시 함수와 혼동하지 않아야 한다.
CRC32의 출력은 보통 **체크섬**이라 부른다

둘째, MD5, SHA-1과 같은 유명한 해시 함수는 오늘날에는 뚫린 것으로 보고 있다.
해시 함수가 깨진 이유는 컴퓨터 성능의 발달 덕이기도 하지만 근본적으로 해시 함수의 설계 방식 자체에서 결함이 발견

### SHA-2 해시 함수

SHA-2는 NSA에서 발명하고 2001년 NIST에서 표준화됐다.
SHA-2는 NIST에서 이전에 표준화됐으나, 노후화된 SHA-1의 공식 후속 표준이기도 하다.
SHA-2에는 4가지 다른 버전이 있고 각 224, 256, 384, 512비트의 출력을 생성한다.
각 공식 이름은 SHA-224, SHA-256, SHA-384, SHA-512 dlek.

SHA-256은 세 가지 보안 속성에 필요한 최소 128비트의 보안을 제공
보안에 더 엄격한 애플리케이션은 SHA-512를 사용한다.

**압축 함수** 라는 특수 함소로 시작된다.
압축 함수는 어떤 크기의 두 입력을 받아서 한쪽 입력의 크기에 해당하는 하나의 출력을 생성
SHA-2는 블록암호(고정 크기의 데이터 블ㄹㄹ록을 암호화할 수 있는 암호)에 의존하는 **데이비스-메이어** 방법을 사용한다.

SHA-2는 이러한 압축 함수를 반복적으로 호출하여 메세지를 해시하는 알고리즘인 **머클-담고르** 구조다.
구체적으로 다음 두 단계를 거쳐 작동한다.

먼저 해시하려는 입력에 패딩을 적용한 다음 입력을 압축 함수에 맞는 블록으로 자른다. 여기서 패딩은 길이를 블록 크기의 배수로 만들기 위해 입력에 특정 바이트를 추가하는 것을 의미
패딩된 입력을 동일한 블록 크기로 자르면 압축 함수의 첫 번째 인수에 맞출 수 있다.

둘쨰, 압축 함수의 이전 출력을 압축 함수에 대한 두번쨰 인수로 사용하여 압축함수를 메세지 블록에 반복적으로 적용한다. 최종 출력이 다이제스트가 된다.

> 머클-담고르 구조는 압축 함수 자체가 있는 한 충돌 저항성을 가진다는 증명이 이미 이루어졌다.
> 따라서 임의 길이 입력을 가지는 해시 함수의 보안은 고정 크기 압축 함소의 보안과 같고, 설계 및 분석이 더 용잉해진다.

처음에는 압축 함수의 두 번쨰 인수를 보통 "nothing-up-my-sleeve" 값으로 고정하고 표준화된다.

SHA-256인 경우 첫 번쨰 소수의 제곱근을 사용하여 이 값을 도출한다.

> SHA-2는 사용하기에 완벽한 해시 함수지만 비밀을 해시하기에는 적합하지 않다. 머클-담고르 구조의 단점 때문인데, SHA-2를 비밀에 사용하는 경우 특정 공격(길이 확장 공격)에 취약하다

### SHA-3 해시 함수

### ???

제2 역상 저항성
커밋 체계 (commitment scheme)
